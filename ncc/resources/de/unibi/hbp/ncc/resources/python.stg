define_builder(modinst) ::= <<
<(modinst.defineBuilderTemplateName)()>
>>

define_neuronType(neuronType) ::= <<
<neuronType.parametersPythonName> = {
    <neuronType.neuronParameters:{it | '<it.pythonName>': <it.value>}; separator=",\n">
}
>>

define_module_instance(modinst) ::= <<
<modinst.pythonName> = <(modinst.buildInstanceTemplateName)(modinst)>
>>

define_population(pop) ::= <<
<pop.pythonName> = sim.Population(<pop.neuronCount>, sim.<pop.neuronType.neuronKind.pythonName>, <pop.neuronType.parametersPythonName>, label="<pop.name>")
>>

define_spikeSource(src) ::= <<
<src.pythonName> = sim.Population(<src.neuronCount>, sim.SpikeSourceArray(spike_times=<\\>
<if(src.twoDimensional)>[
    <src.twoLevelTimes:{it | [<it; separator=", ",wrap="\n    ">]}; separator=",\n">]<\\>
<else>[<src.singleLevelTimes; separator=", ",wrap="\n    ">]<\\>
<endif>), label="<src.name>")
>>

define_poissonSource(poi) ::= <<
<poi.pythonName> = sim.Population(<poi.neuronCount>,<\\>
sim.SpikeSourcePoisson(rate=<poi.rate>, start=<poi.start>, duration=<poi.duration>), label="<poi.name>")
>>

define_connectorKind(cnk) ::= <<
<if(!cnk.kindSpecificProps)><cnk.pythonName> = sim.<cnk.pyNNClassName>()<endif>
>>

define_outgoingSynapses(connectable) ::= <<
<connectable.outgoingSynapses:define_oneSynapse(); separator="\n">
>>

port_population(port) ::= <<
<port.owningModule.pythonName>['<port.directionAsString>'][<port.index>]
>>

define_oneSynapse(con) ::= <<
sim.Projection(<\\>
<if(con.sourceNamedEntity)><con.sourceNamedEntity.pythonName><else><port_population(con.sourceModulePort)><endif>, <\\>
<if(con.targetNamedEntity)><con.targetNamedEntity.pythonName><else><port_population(con.targetModulePort)><endif>, <\\>
<if(!con.synapseType.connectorKind.kindSpecificProps)><\\>
<con.synapseType.connectorKind.pythonName>, <\\>
<else><\\>
sim.<con.synapseType.connectorKind.pyNNClassName>(<con.synapseType.connectorParameters:{it | <it.pythonName>=<it.value>}; separator=", ">), <\\>
<endif><\\>
sim.<con.synapseType.synapseKind.pyNNClassName>(weight=<con.synapseType.absoluteWeight>, delay=<con.synapseType.delay>)<\\>
<if(con.synapseType.inhibitory)>, receptor_type="inhibitory"<endif><\\>
)
>>

define_moduleOutputSynapses(modinst) ::= <<
<modinst.outputPorts:define_outgoingSynapses()>
>>

probe_target(probe) ::= <<
<if(probe.targetNamedEntity)><probe.targetNamedEntity.pythonName><else><port_population(probe.targetModulePort)><endif>
>>

instrument_oneProbeTarget(target, targetName) ::= <<
<targetName>.record([<target.requiredDataSeries:{it | '<it.pythonName>'}; separator=", ">])
<! TODO do we need to consolidate multiple probe edges between two nodes into one record call with multiple arguments !>
>>

instrument_populationProbes(pop) ::= <<
<if(pop.anyIncomingProbes)><instrument_oneProbeTarget(pop, pop.pythonName)><endif>
>>

instrument_portProbes(port) ::= <<
<if(port.anyIncomingProbes)><instrument_oneProbeTarget(port, port_population(port))><endif>
>>

instrument_modulePortProbes(modinst) ::= <<
<modinst.outputPorts:instrument_portProbes()>
>>

probe_target_gid(probe) ::= <<
<if(probe.targetNamedEntity)><probe.targetNamedEntity.unadornedPythonName><else><port_gid(probe.targetModulePort)><endif>
>>

port_gid(port) ::= <<
<port.owningModule.unadornedPythonName>_<port.directionAsString>_<port.unadornedPythonName>
>>

// TODO code generation for analog signals
// TODO cyclic multi-colored graphs
// TODO legend fix still required?
create_panel(probe) ::= <<
    Panel(
        <probe_target(probe)>.get_data().segments[0].spiketrains,
        xlabel="Time (ms)", xticks=True,
        gid='<probe_target_gid(probe)>',
        line_properties= [{'color': 'b'}, ],
    ),
>>

create_plot(plot, target) ::= <<
fig = Figure(
<plot.outgoingProbesSorted:create_panel(); separator="\n">
  title="<plot.name>",
  annotations="Simulated with <target.displayName>"
)
fix_legends(fig)
fig.save("<plot.outputFileName>")
fig.fig.clear()
>>

program(prog, scope, target) ::= <<
import numpy.random
from pyNN.utility import get_simulator
from pyNN.utility.plotting import Figure, Panel

<scope.oneModuleInstancePerUsedClass:define_builder(); separator="\n\n\n">


<scope.neuronTypes:define_neuronType(); separator="\n"><! TODO output referenced neuron types only !>

runtime = <prog.runTime>

sim, options = get_simulator(("--image-viewer", "Executable for displaying PNG images of plots", {"default": '-'}))

sim.setup(timestep=<prog.timeStep>)
<scope.standardPopulations:define_population(); separator="\n">
<scope.spikeSources:define_spikeSource(); separator="\n">
<scope.poissonSources:define_poissonSource(); separator="\n">

<scope.moduleInstances:define_module_instance(); separator="\n">

<scope.neuronPopulations:instrument_populationProbes(); separator="\n">
<scope.moduleInstances:instrument_modulePortProbes(); separator="\n">

<scope.connectorKinds:define_connectorKind(); separator="\n"><! (minor) TODO output referenced connector kinds only !>

<scope.neuronPopulations:define_outgoingSynapses(); separator="\n">

<scope.moduleInstances:define_moduleOutputSynapses(); separator="\n">

sim.run(runtime)

from matplotlib.axes import Axes

def fix_legends(pynn_fig):
   for panel in pynn_fig.fig.get_children():
      if isinstance(panel, Axes):
         gids = [ child.get_gid() for child in panel.get_children() if child.get_gid() ]
         if gids:
            panel.legend(gids[0].split(', '))


<scope.dataPlots:create_plot(target); separator="\n">


if options.image_viewer != '-':
  import subprocess
  subprocess.run([options.image_viewer, <scope.dataPlots:{it | it.outputFileName}; separator=", ">])

sim.end()
>>
